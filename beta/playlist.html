<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--

    $Id: playlist.html,v 1.1 2022/07/07 04:18:37 dfm Exp dfm $
    $Log: playlist.html,v $
    Revision 1.1  2022/07/07 04:18:37  dfm
    Initial revision


    build playlist for an event with google drive links to the mp3s
    this version uses musiclib.xml and eventlist.xml

-->
<title id="doctitle">Tuners playlist</title>
<link rel="stylesheet" href="select.css" />
<style>
.hidden { display: none; }
.paused { background-image: linear-gradient(to right, yellow, yellow); }
.playing { background-color: lightgreen; }
#wrapper { width: 528px; }
#pltab, #plcapt, .plctrl, .partsel, #selevent, #selsongs { width: 100%; }
#plcapt { border: 2px solid black; text-align: center; font: bold 20px Arial; background-color: lightgreen; }
#repeats { width: 2em; }
.sep { margin-left: 20px; }
input[type=number]::-webkit-inner-spin-button { opacity: 1 }
input[type=checkbox] { border: 5px solid pink; }
div[id^='vtrk'] { font: bold 20px Arial; }
label, legend, .bigger, .venue { font-family: Arial; font-size: larger; }
[id^='vtrk']:nth-child(even) { background: #CCC }
[id^='vtrk']:nth-child(odd) { background: #FFF }
img { width:40px; height:40px; }
img { padding: 6px calc(100%/8 - 22px); }
.blink { animation: blink 3s linear infinite; }
@keyframes blink { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
h3 { font-size: xx-large; }
</style>
<script src="formatDate.js"></script>
<script src="getMusicLib.js"></script>
<script src="getEventList.js"></script>
<script>

var nevshow = 999; // max. events for event select
var qtetSongs = [];
var songlib = [];
var songlist = [];
var songpath = [];
var voice;
var when, where;

// encoded svg for the player control images
// idea from https://codepen.io/tigt/post/optimizing-svgs-in-data-uris 
var resetsvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='20' fill='lightgray'/%3E
%3Cg%3E
%3Cpath d='M 75 150 A 75 75, 0, 1, 1, 96.97 203.03' stroke='crimson' fill='none' stroke-width='40'/%3E
%3Cpolygon points='30 175, 75 130, 120 175' stroke='crimson' fill='crimson' stroke-width='1'
 transform='translate(21.97 53.03) rotate(-45 75 150)'/%3E
%3C/g%3E
%3C/svg%3E`;

var resetsvgan = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='20' fill='crimson'/%3E
%3Cg%3E
%3Cpath d='M 75 150 A 75 75, 0, 1, 1, 96.97 203.03' stroke='lightgray' fill='none' stroke-width='40'/%3E
%3Cpolygon points='35 170, 75 130, 115 170' stroke='lightgray' fill='lightgray' stroke-width='1'
 transform='translate(21.97 53.03) rotate(-45 75 150)'/%3E
%3CanimateTransform attributeName='transform' attributeType='XML' type='rotate'
 from='0 150 150' to='360 150 150' dur='5s' repeatCount='indefinite'/%3E
%3C/g%3E
%3C/svg%3E`;

var prevsvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='21' fill='lightblue'/%3E
%3Cpolygon points='95.00 150.00, 207.50 85.05, 207.50 214.95' stroke='black' fill='black' stroke-width='1'/%3E
%3Cline x1='85' x2='85' y1='210' y2='90' stroke='black' stroke-width='21' stroke-linecap='round'/%3E
%3C/svg%3E`;

var playsvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='21' fill='lightgreen'/%3E
%3Cpolygon points='225.00 150.00, 112.50 214.95, 112.50 85.05' stroke='black' fill='black' stroke-width='1'/%3E
%3C/svg%3E`;

var nextsvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='21' fill='lightblue'/%3E
%3Cpolygon points='205.00 150.00, 92.50 214.95, 92.50 85.05' stroke='black' fill='black' stroke-width='1'/%3E
%3Cline x1='215' x2='215' y1='210' y2='90' stroke='black' stroke-width='21' stroke-linecap='round'/%3E
%3C/svg%3E`;

var pausesvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='21' fill='lightpink'/%3E
%3Cline x1='120' x2='120' y1='210' y2='90' stroke='black' stroke-width='21' stroke-linecap='round'/%3E
%3Cline x1='180' x2='180' y1='210' y2='90' stroke='black' stroke-width='21' stroke-linecap='round'/%3E
%3C/svg%3E`;

// event listener called about 4/second by playing audio
// updates the progress bar for the track.
function timeupevlstn() {
    numelcalls++;
    var currentTime = audel.currentTime;
    var duration = audel.duration;
    let pct = 100.0*(currentTime +.25)/duration;
    document.getElementById(vtrkid).style.backgroundImage = `linear-gradient(to right, lightgreen ${pct}%, yellow ${pct}%)`;
}

function havepart(el) {
    voice = el.value;
    let selel = document.querySelector("#selevent");
    if (selel.classList.contains("hidden")) {
        selel.classList.remove("hidden");
    } else {
        // playlist was already showing, voice changed ->
        // need to redo the playlist
        playlist();
    }
}

function play(req) {
    // start the audio
    console.log(`in play for ${req}`);
    const playPromise = audel.play();
    if (playPromise) {
        playPromise
        .then(_ => {
            // promise has completed successfully - update UI
            console.log(`successful promise for ${req}`);
        })
        .catch(err => {
            console.log(`in play for req ${req}, err is ${err}`);
        });
    }
    // ensure no track is marked "paused"
    let pptrk = document.querySelector(".paused");
    if (pptrk) {
        pptrk.classList.remove("paused");
    }
}
function pause() {
    // if we haven't set audel, just leave
    if (audel) {
        // issue the pause, clean up if a promise was in progress
        audel.pause();
        let pptrk = document.querySelector(".playing");
        if (pptrk) {
            pptrk.classList.remove("playing");
        }
        if (playPromise) {
            playPromise
            .then(_ => {
            })
            .catch(err => {
                console.log(`in pause, err is ${err}`)
            });
        }
        // promise has completed - update UI
        let trkdiv = document.getElementById(vtrkid);
        trkdiv.classList.add("paused");
        ppimg.src = playsvg;
        ppimg.classList.add("blink");
        console.log(`${vtrkid} paused at ${audel.currentTime}`);
    }
}

function nextsong(dir) {
    // requestor is ppimg when user sets playlist and then clicks play.
    // it is previmg and nextimg when invoked by the prev and next buttons, and
    // it is audel when invoked by song end.

    let rqstr = event.target.id;
    if (rqstr == "audel") {
        // called by song ended listener
        if (doitagain > 0) {
            console.log(`progress was updated ${numelcalls} times`);
            numelcalls = 0;
            doitagain--;
            play('song ended');
            console.log(`restarting ${vtrkid}, doitagain now ${doitagain}`);
            return;
        }
    }

    let curtrks = [];
    let activendx = -1;
    // get the song row divs
    let seltrks = document.querySelectorAll("div[id^='vtrk']");
    let ndx = 0;

    for (let curtrk of seltrks) {
        // find the track marked playing, if one exists. remove
        // playing status, clear the progress bar, save the row
        // index for the "active" track, and call pause to update the UI.
        if (curtrk.classList.contains("playing")) {
            curtrk.classList.remove("playing");
            curtrk.style.backgroundImage = "";
            activendx = ndx;
            pause();
        }
        chkd = curtrk.children[0].checked;
        if (chkd) {
            curtrks.push(curtrk.id);
            ndx++;
        }
    }
    if (curtrks.length < 1) {
        // no tracks are selected. avoid infinite loop!
            alert("no tracks selected!");
        return;
    }

    let songsrc = "";
    activendx += dir;
    if (activendx > curtrks.length - 1) {
        activendx = 0;
    } else if (activendx < 0) {
        activendx = curtrks.length - 1;
    }
    vtrkid = curtrks[activendx];
    let trkdiv = document.getElementById(vtrkid);
    let gid = trkdiv.children[0].value;
    songsrc = "https://docs.google.com/uc?export=download&id=" + gid;
    // songsrc = `/dfm_ws/NormTracks/${songpath[gid]}`;
    if (! audel) {
        audel = document.getElementById("audel");
        audel.addEventListener("playing", function() {
            // called when track is actually playing
            // while a song is playing, the button shows pause.
            ppimg.src = pausesvg;
            ppimg.classList.remove("blink");
            let trkdiv = document.getElementById(vtrkid);
            trkdiv.classList.add("playing");
            let nam = document.getElementById(vtrkid).innerText;
            console.log(`starting ${vtrkid}: ${nam} (${audel.duration.toFixed(2)})`);
        });
        audel.addEventListener("timeupdate", timeupevlstn, false);
    }
    doitagain = document.querySelector("#repeats").value - 1;
    audel.src = songsrc;
    trkdiv.classList.add("playing");
    play('next song');
    numelcalls = 0;
}
var audel;
var ppimg;
var playPromise;
var doitagain = 0;
var vtrkid;
var numelcalls;
function playpause() {
    // play/pause button clicked. if audel not set,
    // user is starting the player. just call nextsong.
    // if audel is set, user is toggling between play and pause.
    if (audel) {
        if (audel.src != "") {
            if (audel.paused) {
                play('unpause');
            } else {
                pause();
            }
        }
    } else {
        nextsong(1);
    }
}
function prevsong() {
    // if song has started, restart.
    // otherwise, back up to previous song in list.
    let cur = audel.currentTime;
    let dur = audel.duration;
    if (cur > 3.0) {
        audel.currentTime = 0.0;
        console.log(`restarted after ${cur} of ${dur}`);
    } else {
        console.log(`backing up after ${cur} of ${dur}`);
        nextsong(-1);
    }
}
function setclear(el) {
    let sorc = el.checked;
    let cbs = document.querySelectorAll("input[type='checkbox']");
    for (let cb of cbs) {
        cb.checked = sorc;
    }
}
function playlist() {
    // the part has been selected and the event selected.
    //  create and display the playlist for it.

    document.querySelector("#selevent").classList.add("hidden");
    document.querySelector("#selsongs").classList.remove("hidden");

    let pltab = document.querySelector("#pltab");

    let html = `<div id="setclr" class="bigger"><input type="checkbox" checked onclick="setclear(this)">Set/Clear All</div>\n`;
    let trkno = 0;
    for (let sid of songlist) {
        if (qtetSongs.includes(sid)) {
            continue;
        }
        let song = musiclib[sid];
        let nam = song.name;
        if (song.hasOwnProperty('notes')) {
            nam += " (" + song.notes + ")";
        }
        if (song.hasOwnProperty('location')) {
            nam += " [" + song.location + "]";
        }
        if (song.hasOwnProperty('tracks')) {
            if (song['tracks'].hasOwnProperty(voice)) {
                for (let vtr of song['tracks'][voice]) {
                    trkno++;
                    let gdid = vtr['gdid'];
                    let mods = vtr['mods'];
                    let snam = nam;
                    if (mods != "") {
                        snam += ": " + mods;
                    }
                    html += `<div id="vtrk${trkno}"><input type="checkbox" checked value="${gdid}">${snam}</div>`;
                }
            }
        }
    }
    pltab.innerHTML = html;
    document.querySelector(".plctrl").classList.remove("hidden");
    let plcapt = document.querySelector("#plcapt");
    plcapt.innerText = `${where} - ${when}`;
}

function init() {
    let mlurl = "musiclib.xml";
    let gmlpromise = getMusicLib(mlurl);

    let elurl = "events.xml";
    let gelpromise = getEventList(elurl);

    let promises = [gmlpromise, gelpromise];

    Promise.all(promises).then(values => {
        // musiclib and eventlist loads are complete.
        musiclib = values[0];
        eventlist = values[1];

        // populate the event select
        let selel = document.getElementById("events");
        let opt = document.createElement("option");
        opt.dataset.dtndx = "";
        opt.text = "Select event";
        selel.add(opt);

        let newestFirst = Object.keys(eventlist).sort((a, b) => a < b ? 1 : a > b ? -1 : 0);
        
        let nadd = 0;
        for (let ndx of newestFirst) {
            let ev = eventlist[ndx];

            opt = document.createElement("option");
            opt.dataset.dtndx = ndx;
            opt.text = `${ev['where']} - ${ev['when']}`;
            selel.add(opt);
            nadd += 1;
            if (nadd >= nevshow) {
                break;
            }
        }

        // next, set up voice
        let defaultVoice = localStorage.getItem("defaultVoice");
        if (! defaultVoice) { defaultVoice = "mix"; }
        let buttonId = defaultVoice + "p";
        let butt = document.getElementById(buttonId);
        butt.click();

        // initialize the control buttons
        document.querySelector("#resetimg").src = resetsvg;
        document.querySelector("#previmg").src = prevsvg;
        document.querySelector("#nextimg").src = nextsvg;

        ppimg = document.querySelector("#ppimg");
        ppimg.src = playsvg;
        ppimg.classList.add("blink");
    });
}
function eventsel() {
    // event has been selected from the list
    // event target is the selected event div. get the 
    // event from eventlist.
    let targ = event.target;
    let ndx = targ.options.selectedIndex;
    let opt = targ.options[ndx];
    let dtndx = opt.dataset.dtndx;
    let ev = eventlist[dtndx];
    when = ev['when'];
    where = ev['where'];
    songlist = ev['songlist'];
    qtetSongs = [];
    if (ev.hasOwnProperty('qtetSongs')) {
        qtetSongs = ev['qtetSongs'];
    }
    playlist();
}
var repeats;
function setrepeat(el) {
    repeats = el.value;
}
function resetfn() {
    // if we've never located the audio element, just leave
    if (audel) {
        // reset button pushed. stop audio, set play/pause to play (blinking)
        // if a promise is outstanding, wait for it to complete, 

        // don't remove the listener unless we find a way to put it back....
        // audel.removeEventListener("timeupdate", timeupevlstn, false);

        pause();

        audel.currentTime = 0.0;
        // if a track is paused or playing, remove that from classlist
        let pptrk = document.querySelector(".paused,.playing");
        if (pptrk) {
            pptrk.classList.remove("paused");
            pptrk.classList.remove("playing");
            pptrk.style.backgroundImage = "";
        }
    }
}
</script>
</head>
<body onload='init()'>
<div id="wrapper">
<fieldset class='partsel'>
 <legend>Select voice</legend>
  <input type="radio" id="bassp" name="voicepart" onclick="havepart(this)" value="bass">
  <label for="bassp">bass</label>
  <input type="radio" id="barip" name="voicepart" onclick="havepart(this)" value="bari">
  <label for="barip">bari</label>
  <input type="radio" id="leadp" name="voicepart" onclick="havepart(this)" value="lead">
  <label for="leadp">lead</label>
  <input type="radio" id="tenorp" name="voicepart" onclick="havepart(this)" value="tenor">
  <label for="tenorp">tenor</label>
  <input type="radio" id="mixp" name="voicepart" onclick="havepart(this)" value="mix">
  <label for="mixp">mix</label>
  <label for="repeats" class="sep">Repeats</label>
  <input type="number" id="repeats" name="repeats" min="0" max="3" value="1" oninput="setrepeat(this)">
</fieldset>
<fieldset id="selevent" class="hidden" onchange="eventsel()">
<legend>Select an event</legend>
<select id="events" class="select-css"></select>
</fieldset>
<fieldset id="selsongs" class="hidden">
<legend>Select Songs</legend>
<div id="plcapt"></div>
<div id="pltab"></div>
</fieldset>
<fieldset class='hidden plctrl'>
<legend>Control Playback</legend>
<img id="resetimg" src="" title="reset" onclick="resetfn()">
<img id="previmg" src="" title="restart/previous song" onclick="prevsong()">
<img id="ppimg" src="" title="play/pause" onclick="playpause()">
<img id="nextimg" src="" title="next song" onclick="nextsong(1)">
</fieldset>
</div>
<audio id="audel" onended="nextsong(1)" src=""></audio>
</body>
</html>
