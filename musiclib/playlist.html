<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--

    $Id: playlist.html,v 1.1 2022/03/24 18:34:55 dfm Exp dfm $
    $Log: playlist.html,v $
    Revision 1.1  2022/03/24 18:34:55  dfm
    Initial revision


    build playlist for an event with google drive links to the mp3s
-->
<title id="doctitle">Tuners playlist</title>
<style>
.hidden { display: none; }
.paused { background-image: linear-gradient(to right, yellow, yellow); }
.playing { background-color: lightgreen; }
#wrapper { width: 528px; }
#pltab, #plcapt, .plctrl, .partsel, #selevent, #selsongs { width: 100%; }
#plcapt { text-align: center;
    font-family: Arial; font-weight: bold; font-size: larger;
    background-color: lightgreen; }
#repeats { width: 2em; }
.sep { margin-left: 20px; }
input[type=number]::-webkit-inner-spin-button { opacity: 1 }
div[id^='vtrk'] { font-family: Arial; font-weight: bold; }
label, legend, .bigger, .venue { font-family: Arial; font-size: larger; }
img { width:40px; height:40px; }
img { padding: 6px calc(100%/8 - 22px); }
.blink { animation: blink 3s linear infinite; }
@keyframes blink { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
h3 { font-size: xx-large; }
</style>
<script>

// encoded svg for the player control images
// idea from https://codepen.io/tigt/post/optimizing-svgs-in-data-uris 
var resetsvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='20' fill='lightgray'/%3E
%3Cg%3E
%3Cpath d='M 75 150 A 75 75, 0, 1, 1, 96.97 203.03' stroke='crimson' fill='none' stroke-width='40' /%3E
%3Cpolygon points='30 175, 75 130, 120 175' stroke='crimson' fill='crimson' stroke-width='1'
transform='translate(21.97 53.03) rotate(-45 75 150)' /%3E
%3C/g%3E
%3C/svg%3E`;

var resetsvgan = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='20' fill='crimson'/%3E
%3Cg%3E
%3Cpath d='M 75 150 A 75 75, 0, 1, 1, 96.97 203.03' stroke='lightgray' fill='none' stroke-width='40' /%3E
%3Cpolygon points='35 170, 75 130, 115 170' stroke='lightgray' fill='lightgray' stroke-width='1'
transform='translate(21.97 53.03) rotate(-45 75 150)' /%3E
%3CanimateTransform attributeName='transform' attributeType='XML' type='rotate'
from='0 150 150' to='360 150 150' dur='5s' repeatCount='indefinite' /%3E
%3C/g%3E
%3C/svg%3E`;

var prevsvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='21' fill='lightblue'/%3E
%3Cpolygon points='95.00 150.00, 207.50 85.05, 207.50 214.95' stroke='black' fill='black' stroke-width='1'/%3E
%3Cline x1='85' x2='85' y1='210' y2='90' stroke='black' stroke-width='21' stroke-linecap='round'/%3E
%3C/svg%3E`;

var playsvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='21' fill='lightgreen'/%3E
%3Cpolygon points='225.00 150.00, 112.50 214.95, 112.50 85.05' stroke='black' fill='black' stroke-width='1'/%3E
%3C/svg%3E`;

var nextsvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='21' fill='lightblue'/%3E
%3Cpolygon points='205.00 150.00, 92.50 214.95, 92.50 85.05' stroke='black' fill='black' stroke-width='1'/%3E
%3Cline x1='215' x2='215' y1='210' y2='90' stroke='black' stroke-width='21' stroke-linecap='round'/%3E
%3C/svg%3E`;

var pausesvg = `data:image/svg+xml;utf8,
%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='300' height='300'%3E
%3Ccircle cx='150' cy='150' r='140' stroke='black' stroke-width='21' fill='lightpink'/%3E
%3Cline x1='120' x2='120' y1='210' y2='90' stroke='black' stroke-width='21' stroke-linecap='round'/%3E
%3Cline x1='180' x2='180' y1='210' y2='90' stroke='black' stroke-width='21' stroke-linecap='round'/%3E
%3C/svg%3E`;

// event listener called about 4/second by playing audio
// updates the progress bar for the track.
function timeupevlstn() {
    numelcalls++;
    var currentTime = audel.currentTime;
    var duration = audel.duration;
    let pct = 100.0*(currentTime +.25)/duration;
    document.getElementById(vtrkid).style.backgroundImage = `linear-gradient(to right, lightgreen ${pct}%, yellow ${pct}%)`;
}

function play(req) {
    // start the audio
    console.log(`in play for ${req}`);
    const playPromise = audel.play();
    if (playPromise) {
        playPromise
        .then(_ => {
            // promise has completed successfully - update UI
            console.log(`successful promise for ${req}`);
        })
        .catch(err => {
            console.log(`in play for req ${req}, err is ${err}`);
        });
    }
    // ensure no track is marked "paused"
    let pptrk = document.querySelector(".paused");
    if (pptrk) {
        pptrk.classList.remove("paused");
    }
}
function pause() {
    // if we haven't set audel, just leave
    if (audel) {
        // issue the pause, clean up if a promise was in progress
        audel.pause();
        let pptrk = document.querySelector(".playing");
        if (pptrk) {
            pptrk.classList.remove("playing");
        }
        if (playPromise) {
            playPromise
            .then(_ => {
            })
            .catch(err => {
                console.log(`in pause, err is ${err}`)
            });
        }
        // promise has completed - update UI
        let trkdiv = document.getElementById(vtrkid);
        trkdiv.classList.add("paused");
        ppimg.src = playsvg;
        ppimg.classList.add("blink");
        console.log(`${vtrkid} paused at ${audel.currentTime}`);
    }
}

function nextsong(dir) {
    // requestor is ppimg when user sets playlist and then clicks play.
    // it is previmg and nextimg when invoked by the prev and next buttons, and
    // it is audel when invoked by song end.

    let rqstr = event.target.id;
    if (rqstr == "audel") {
        // called by song ended listener
        if (doitagain > 0) {
            console.log(`progress was updated ${numelcalls} times`);
            numelcalls = 0;
            doitagain--;
            play('song ended');
            console.log(`restarting ${vtrkid}, doitagain now ${doitagain}`);
            return;
        }
    }

    let curtrks = [];
    let activendx = -1;
    // get the song row divs
    let seltrks = document.querySelectorAll("div[id^='vtrk']");
    let ndx = 0;

    for (let curtrk of seltrks) {
        // find the track marked playing, if one exists. remove
        // playing status, clear the progress bar, save the row
        // index for the "active" track, and call pause to update the UI.
        if (curtrk.classList.contains("playing")) {
            curtrk.classList.remove("playing");
            curtrk.style.backgroundImage = "";
            activendx = ndx;
            pause();
        }
        chkd = curtrk.children[0].checked;
        if (chkd) {
            curtrks.push(curtrk.id);
            ndx++;
        }
    }
    if (curtrks.length < 1) {
        // no tracks are selected. avoid infinite loop!
            alert("no tracks selected!");
        return;
    }

    let songsrc = "";
    activendx += dir;
    if (activendx > curtrks.length - 1) {
        activendx = 0;
    } else if (activendx < 0) {
        activendx = curtrks.length - 1;
    }
    vtrkid = curtrks[activendx];
    let trkdiv = document.getElementById(vtrkid);
    let gid = trkdiv.children[0].value;
    songsrc = "https://docs.google.com/uc?export=download&id=" + gid;
    // songsrc = `/dfm_ws/NormTracks/${songpath[gid]}`;
    if (! audel) {
        audel = document.getElementById("audel");
        audel.addEventListener("playing", function() {
            // called when track is actually playing
            // while a song is playing, the button shows pause.
            ppimg.src = pausesvg;
            ppimg.classList.remove("blink");
            let trkdiv = document.getElementById(vtrkid);
            trkdiv.classList.add("playing");
            let nam = document.getElementById(vtrkid).innerText;
            console.log(`starting ${vtrkid}: ${nam} (${audel.duration.toFixed(2)})`);
        });
        audel.addEventListener("timeupdate", timeupevlstn, false);
    }
    doitagain = document.querySelector("#repeats").value - 1;
    audel.src = songsrc;
    trkdiv.classList.add("playing");
    play('next song');
    numelcalls = 0;
}
var audel;
var ppimg;
var playPromise;
var doitagain = 0;
var vtrkid;
var numelcalls;
function playpause() {
    // play/pause button clicked. if audel not set,
    // user is starting the player. just call nextsong.
    // if audel is set, user is toggling between play and pause.
    if (audel) {
        if (audel.src != "") {
            if (audel.paused) {
                play('unpause');
            } else {
                pause();
            }
        }
    } else {
        nextsong(1);
    }
}
function prevsong() {
    // if song has started, restart.
    // otherwise, back up to previous song in list.
    let cur = audel.currentTime;
    let dur = audel.duration;
    if (cur > 3.0) {
        audel.currentTime = 0.0;
        console.log(`restarted after ${cur} of ${dur}`);
    } else {
        console.log(`backing up after ${cur} of ${dur}`);
        nextsong(-1);
    }
}

var urls = [];
function cheatindex(chndx) {
    // create the list of events from the cheats index
    let html = "";
    let cheats = chndx.querySelectorAll("a");
    for (let cheat of cheats) {
        html += `<div class="venue">${cheat.textContent}</div>\n`;
        urls[cheat.textContent] = cheat.href;
    }
    document.querySelector("#eventsdiv").innerHTML = html;
    document.querySelector(".partsel").classList.remove("hidden");
}
function setclear(el) {
    let sorc = el.checked;
    let cbs = document.querySelectorAll("input[type='checkbox']");
    for (let cb of cbs) {
        cb.checked = sorc;
    }
}
function playlist(cheathtml, voice) {
    // the part has been selected and the event cheat sheet has been loaded.
    //  create and display the playlist for it.

    document.querySelector("#selevent").classList.add("hidden");
    document.querySelector("#selsongs").classList.remove("hidden");

    let pltab = document.querySelector("#pltab");
    pltab.innerHTML = "";

    let voicesel = "." + voice;
    let songs = cheathtml.querySelectorAll(voicesel);
    let html = `<div id="setclr" class="bigger"><input type="checkbox" checked onclick="setclear(this)">Set/Clear All</div>\n`;
    let trkno = 0;
    for (let song of songs) {
        trkno++;
        if (song.tagName == "A") {
            // console.log(`type A: ${song.textContent}, ${song.href}`);
            let gdid = song.href.split("id=")[1];
            html += `<div id="vtrk${trkno}"><input type="checkbox" checked value="${gdid}">${song.textContent}</div>`;
        } else if (song.tagName == "DIV") {
            let trax = song.querySelectorAll("a");
            for (let a of trax) {
                let gdid = a.href.split("id=")[1];
                html += `<div id="vtrk${trkno}"><input type="checkbox" checked value="${gdid}">${a.textContent}</div>`;
                trkno++;
            }
        } else if (song.tagName == "TR") {
            let trax = song.querySelectorAll("a");
            if (trax) {
                for (let a of trax) {
                    let gdid = a.href.split("id=")[1];
                    html += `<div id="vtrk${trkno}"><input type="checkbox" checked value="${gdid}">${a.textContent}</div>`;
                    trkno++;
                }
            }
        } else {
            console.log(`type ${song.tagName}??? WTF?`);
        }
    }
    pltab.innerHTML = html;
    let titlel = cheathtml.querySelector(".tabletitle");
    document.querySelector(".plctrl").classList.remove("hidden");
    let plcapt = document.querySelector("#plcapt");
    plcapt.innerText = `${titlel.textContent}`;
    plcapt.style.fontSize = "1.2em";
}
var songpath = [];
function loadlib(liburl) {
    const xhr = new XMLHttpRequest();
    xhr.onload = function () {
        // musiclib has loaded - build gdid to filepath map
        let musiclib = this.responseXML.documentElement;

        let nids = 0;
        for (let songNode of musiclib.children) {
            for (let prop of songNode.children) {
                if (prop.nodeName == "tracks") {
                    let gdid, path;
                    for (let subp of prop.children) {
                        if (subp.nodeName == "voice") {
                            for (let att of subp.attributes) {
                                if (att.name == 'gdid') {
                                    gdid = att.value;
                                } else if (att.name == 'path') {
                                    path = att.value;
                                }
                            }
                            songpath[gdid] = path;
                            nids++;
                        } else {
                            console.log(`track for ${song} has child ${subp.nodeName}??`);
                        }
                    }
                }
            }
        }
        console.log(`gdid to file-path map has ${nids} entries.`);

        // next, set up voice
        let defaultVoice = localStorage.getItem("defaultVoice");
        if (! defaultVoice) { defaultVoice = "mix"; }
        let buttonId = defaultVoice + "p";
        let butt = document.getElementById(buttonId);
        butt.click();

        document.querySelector("#resetimg").src = resetsvg;
        document.querySelector("#previmg").src = prevsvg;
        document.querySelector("#nextimg").src = nextsvg;

        ppimg = document.querySelector("#ppimg");
        ppimg.src = playsvg;
        ppimg.classList.add("blink");

        // now load cheats index
        const xhr = new XMLHttpRequest();
        xhr.onload = function () {
            // index has loaded - go prepare the list
            cheatindex(this.responseXML.documentElement);
        }
        xhr.onerror = function() {
          console.log("Error while getting index.html.");
        }

        xhr.open("GET", "https://dmotteler.github.io/cheats/index.html");
        xhr.responseType = "document";
        xhr.send();
    }
    xhr.onerror = function() {
      console.log("Error while getting XML.");
    }

    xhr.open("GET", liburl);
    xhr.responseType = "document";
    xhr.send();
}
function init() {
    loadlib("https://dmotteler.github.io/musiclib/musiclib.xml");
}
function eventsel() {
    // event has been selected from the list
    // event target is the selected event div. get the 
    // cheat sheet url from the div, and load the cheat sheet.
    let tdiv = event.target;
    let url = urls[tdiv.innerText];
    console.log(`url: ${url}`);

    const xhr = new XMLHttpRequest();
    xhr.onload = function () {
        // event html has been loaded/parsed. go make the playlist.
        cheathtml = this.responseXML.documentElement;
        playlist(cheathtml, voice);
    }
    xhr.onerror = function() {
      console.log("Error while getting XML.");
    }

    xhr.open("GET", url);
    xhr.responseType = "document";
    xhr.send();
}
var cheathtml;
var voice;
function havepart(el) {
    voice = el.value;
    document.querySelector("#selevent").classList.remove("hidden");
}
var repeats;
function setrepeat(el) {
    repeats = el.value;
}
function resetfn() {
    // if we've never located the audio element, just leave
    if (audel) {
        // reset button pushed. stop audio, set play/pause to play (blinking)
        // if a promise is outstanding, wait for it to complete, 

        // don't remove the listener unless we find a way to put it back....
        // audel.removeEventListener("timeupdate", timeupevlstn, false);

        pause();

        audel.currentTime = 0.0;
        // if a track is paused or playing, remove that from classlist
        let pptrk = document.querySelector(".paused,.playing");
        if (pptrk) {
            pptrk.classList.remove("paused");
            pptrk.classList.remove("playing");
            pptrk.style.backgroundImage = "";
        }
    }
}
</script>
</head>
<body onload='init()'>
<div id="wrapper">
<fieldset class='partsel'>
 <legend>Select voice</legend>
  <input type="radio" id="bassp" name="voicepart" onclick="havepart(this)" value="bass">
  <label for="bassp">bass</label>
  <input type="radio" id="barip" name="voicepart" onclick="havepart(this)" value="bari">
  <label for="barip">bari</label>
  <input type="radio" id="leadp" name="voicepart" onclick="havepart(this)" value="lead">
  <label for="leadp">lead</label>
  <input type="radio" id="tenorp" name="voicepart" onclick="havepart(this)" value="tenor">
  <label for="tenorp">tenor</label>
  <input type="radio" id="mixp" name="voicepart" onclick="havepart(this)" value="mix">
  <label for="mixp">mix</label>
  <label for="repeats" class="sep">Repeats</label>
  <input type="number" id="repeats" name="repeats" min="0" max="3" value="1" oninput="setrepeat(this)">
</fieldset>
<fieldset id="selevent" class="hidden" onclick="eventsel()">
<legend>Select an event</legend>
<div id="eventsdiv"></div>
</fieldset>
<fieldset id="selsongs" class="hidden">
<legend>Select Songs</legend>
<div id="plcapt"></div>
<div id="pltab"></div>
</fieldset>
<fieldset class='hidden plctrl'>
<legend>Control Playback</legend>
<img id="resetimg" src="" title="reset" onclick="resetfn()">
<img id="previmg" src="" title="restart/previous song" onclick="prevsong()">
<img id="ppimg" src="" title="play/pause" onclick="playpause()">
<img id="nextimg" src="" title="next song" onclick="nextsong(1)">
</fieldset>
</div>
<audio id="audel" onended="nextsong(1)" src=""></audio>
</body>
</html>
