<!DOCTYPE html>
<!-- $Id: picksongs.html,v 1.1 2020/09/10 19:42:47 dfm Exp dfm $
     Log: picksongs.html,v $
     Revision 1.1  2020/09/10 19:42:47  dfm
     Initial revision


     provide song list for cheat-sheet song selection

     save the song list to local storage and invoke cheat
-->
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Pick songs</title>
<link rel="stylesheet" href="xmlpick.css" />
<script type="text/javascript">

var songorder = 0;
var songlist = [];

function fmtDate(dstr) {
    // expecting dstr like "2028-02-29T23:04", but anything Date 
    // will accept should do. 
    let monam = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"];

    let d = new Date(dstr);
    let longmon = monam[d.getMonth()];
    let day = d.getDate();
    let dmon = d.getMonth() + 1;
    let yr = d.getFullYear();
    let hr = d.getHours();
    let dmin = d.getMinutes();

    let ampm = "AM";
    if (hr > 11) {
        ampm = "PM";
    }
    if (hr > 12) {
        hr -= 12;
    }

    let mons = dmon.toString().padStart(2, 0);
    let days = day.toString().padStart(2, 0);
    let hrs = hr.toString().padStart(2, 0);
    let mins = dmin.toString().padStart(2, 0);

    // e.g., September 9, 2020 12:29PM
    let datstr = `${longmon} ${day}, ${yr} ${hrs}:${mins}${ampm}`;
    let datndx = yr + mons + days + hrs + mins;
    return([datstr,datndx]);
}
function selme(el) {
    let right_click = false;
    if (el.id == "tabid") {
        event.preventDefault();
        el = event.target.parentNode;
        right_click = true;
    }
    // order cell is first child of the row
    let ordel = el.childNodes[0];

    // nbsp; is char code a0 hex. cell will have
    // that value until it has been selected.
    if (ordel.textContent == "\xa0") {
        songorder += 1;
        ordel.textContent = songorder.toString();
        el.classList.add("chosen");
        if (right_click) {
            el.classList.add("qtet");
        }
    } else {
        // if this song was already chosen,
        //   on right-click, toggle qtet setting.
        //   on left-click, un-choose it and blank out the order.
        if (right_click) {
            if (el.classList.contains("qtet")) {
                el.classList.remove("qtet");
            } else {
                el.classList.add("qtet");
            }
        } else {
            el.classList.remove("chosen");
            el.classList.remove("qtet");
            ordel.textContent = "\xa0";
        }
    }
}

var catSelected = [];
var allcats = [];

function setcats() {
    // make catSelected array agree with cats checkboxes.

    catSelected = [];

    let catsels = document.querySelectorAll("input[name='cats']");

    for (let catel of catsels) {
        // category name follows the checkbox, and has unwanted
        // whitespace after it.
        let cat = catel.nextSibling.textContent.replace(/(\s+$)/,'');
        catSelected[cat] = catel.checked;
    }

    let othersSel = catSelected['Others'];

    // set catSelected for cats that don't have a button.
    // allcats are all of the song categories from the lib.
    for (let cat of allcats) {
        if (! (cat in catSelected)) {
            catSelected[cat] = othersSel;
        }
    }
}

function togcat() {
    // one of the "show category" checkboxes has changed.
    // set the hidden value as appropriate for each row.
    // only set hidden if all categories for the song are un-checked.

    // get current states for the category selections.
    // The Other selection means any of allcats for which there is no button.
    setcats();

    let songrows = document.querySelectorAll(".song");

    for (let songrowel of songrows) {
        let songcats = songrowel.classList;

        // if any of a song's cats (except hidden) is
        // checked, show the song.
        let showit = false;
        let ishidden = false;
        for (let scat of songcats) {
            if (scat == "hidden") {
                ishidden = true;
            } else if (scat == "song") {
            } else if (catSelected[scat]) {
                showit = true;
            }
        }

        if (showit) {
            if (ishidden) {
                // currently hidden, but should be showed.
                songrowel.classList.remove("hidden");
            }
        } else {
            if (! ishidden) {
                // not hidden, but don't showit
                songrowel.classList.add("hidden");
            }
        }
    }
}

function alldone() {
    if (venue == "") {
        alert("Please select a venue from the 'Songs for' menu!");
        return;
    }

    var songs = [];
    var qtetsongs = [];
    for (let element of document.getElementsByClassName("chosen")) {
        let song = element.childNodes[1].textContent;
        if (element.classList.contains("hidden")) {
            if (confirm(`Include hidden song ${song}?`)) {
                let ord = Number(element.childNodes[0].textContent) - 1;
                songs[ord] = song;
                if (element.classList.contains("qtet")) {
                    qtetsongs.push(song);
                }
            }
        } else {
            let ord = Number(element.childNodes[0].textContent) - 1;
            songs[ord] = song;
            if (element.classList.contains("qtet")) {
                qtetsongs.push(song);
            }
        }
    }
    if (songs.length < 1) {
        alert("No songs selected?");
        return;
    }

    // songs array may be sparse if any song was de-selected.
    // json will put 'null' for any empty cell. this gets rid of that.
    var seq = [];
    for (let song of songs) {
        if (song) {
            seq.push(song);
        }
    }

    let datel = document.getElementById("eventdate");
    let evdate = datel.value;

    let [fulldate, datndx] = fmtDate(evdate);

    let newevent = {'when': fulldate, 'where': venue, 'songlist': seq, 'qtetSongs': qtetsongs };
    eventlist[datndx] = newevent;

    // replace the updated event list in local storage.
    localStorage.setItem('TunersEvents', JSON.stringify(eventlist));

    // save the event index in showEvent.
    localStorage.setItem('showEvent', JSON.stringify(datndx));

    // create a select with all song names, save to local storage
    // so editlist doesn't need musiclib.

    let libsel = "<select id='libel'>";
    libsel += `<option style="display:none">`
    for (let s of sortedSongs) {
        libsel += `<option>${s}</option>\n`;
    }
    libsel += "</select>\n";

    localStorage.setItem('songlibsel', JSON.stringify(libsel));

    window.location.href = "ch.html";
}

function loadDoc(doc) {
    // start loading doc. xhr will call docReady when loaded. 

    const xhr = new XMLHttpRequest();
    xhr.onerror = function() {
      console.log("Error while getting XML.");
    }

    xhr.open("GET", doc);
    xhr.responseType = "document";
    xhr.send();

    xhr.onload = function () {
        let musiclib = xhr.responseXML.documentElement;
        // console.log(musiclib.nodeName);

        for (let songNode of musiclib.children) {
            let song = [];
            let categories = [];
            for (let att of songNode.attributes) {
                song[att.name] = att.value;
            }

            let nam = song['name'];
            let sid = song['id'];

            for (let prop of songNode.children) {
                if (prop.nodeName == "alias") {
                    let aka = prop.textContent;
                    if (! songlib.hasOwnProperty(aka)) {
                        songlib[aka] = [];
                    }
                    songlib[aka].push(sid);
                } else if (prop.nodeName == "category") {
                    categories.push(prop.textContent);
                } else if (prop.nodeName == "tracks") {
                    let tracks = [];
                    for (let subp of prop.children) {
                        if (subp.nodeName == "voice") {
                            let voice = [];
                            let vname = 'phony';
                            for (let att of subp.attributes) {
                                if (att.name == 'voice') {
                                    vname = att.value;
                                } else {
                                    voice[att.name] = att.value;
                                }
                            }
                            tracks[vname] = Object.assign(voice);
                        }
                    }
                    song[prop.nodeName] = Object.assign(tracks);
                } else if (prop.nodeName == "sheet") {
                    let sheet = [];
                    for (let att of prop.attributes) {
                        sheet[att.name] = att.value;
                    }
                    song[prop.nodeName] = Object.assign(sheet);
                } else {
                    song[prop.nodeName] = prop.textContent;
                }
            }
            if (categories.length > 0) {
                song['categories'] = Object.assign(categories);
                if (categories.includes("Old")) {
                    nam = nam + " (Old)";
                }
            }

            if (! songlib.hasOwnProperty(nam)) {
                songlib[nam] = [];
            }
            songlib[nam].push(sid);

            // clone the song object and add to list
            if (songobj.hasOwnProperty(sid)) {
                throw "found multiple songs with sid " + sid;
            }
            songobj[sid] = Object.assign(song);
        }
        sortedSongs = Object.keys(songlib).sort();

        let songtable = "";
        for (let song of sortedSongs) {
            for (let sid of songlib[song]) {
                let cls = "class='song " + songobj[sid]['categories'].join(" ") + "'";
                let row = `<tr ${cls} onclick="selme(this)"><td class="ord">&nbsp;</td><td>${song}</td></tr>`;
                songtable += row;
            }
        }
        var songtableel = document.getElementById("songtable")
        songtableel.outerHTML = songtable;

        allcats.sort();

        togcat();
    }
}

var songtableel;
var songlib = [];
var songobj = [];

var venue = "";
var evndx = "";
var eventlist = {};
var nevshow = 5; // number of events from eventlist to show in locations.

function evsel(el) {
    var list = document.getElementById("vensel");
    var opfound = false;
    var opt;
    for (opt of list.options) {
        if (opt.value == el.value) {
            opfound = true;
            break;
        }
    }

    if (opfound) {
        // found the selection in existing list.
        // set evndx to the date/time of the existing event,
        // which is used to get the songlist.

        // get rid of the old date
        venue = opt.value;
        if (venue.includes(" - ")) {
            venue = venue.split(" - ")[0];
        }
        // show just the venue in the select box
        el.value = venue;
        evndx = opt.data_value;
        console.log("existing " + venue);
    } else {
        // user typed in a new venue
        opt = document.createElement('option');
        opt.value = el.value;
        opt.data_value = "";

        venue = opt.value;
        evndx = "";

        list.appendChild(opt);
        console.log("added " + venue);
    }

    var songlist;

    // get count of number of songs flagged as chosen.
    let chosenels = document.querySelectorAll(".chosen");
    let nchosen = chosenels.length;

    // if the selected event value is not blank,
    // it had better be an index into the event list.
    // if it is blank, don't disturb the song selections.
    if (opt.data_value != "") {
        if (nchosen > 0) {
            if (confirm("replace song selections with those from selected event?")) {
                let ev = eventlist[opt.data_value];
                songlist = ev['songlist'];
            } else {
                // user cancelled - get out of here.
                return;
            }
        } else {
            // selected event has a songlist, and no songs yet chosen.
            // start with the selection's list.
            let ev = eventlist[opt.data_value];
            songlist = ev['songlist'];
        }
    } else {
        // no songlist for selected event. if songs had been
        // selected, leave them. if not, reset the table.
        if (songorder < 1) {
            songlist = [];
         } else {
            return;
         }
    }

    // check the songlist for songs not in the current library, and for
    // songs in the library but in un-selected categories. Think "Christmas".
    for (let song of songlist) {
        if (song in songlib) {
            let songactive = false;
            for (sid of songlib[song]) {
                for (cat of songobj[sid]['categories']) {
                    if (cat in catSelected && catSelected[cat]) {
                        songactive = true;
                    }
                }
            }
            if (! songactive) {
                console.log("no cat active for " + song);
            }
        } else {
            console.log(song + " not in songlib!");
        }
    }

    // event selected has no songlist, no songs had been selected, or
    // user says replace selected ones from the old event. init the table.

    // for each song row...
    for (let element of document.getElementsByClassName("song")) {
        // get the song name
        let song = element.childNodes[1].textContent;
        // see if it's in the list of songs we want
        let neword = songlist.indexOf(song) + 1;
        // ordel is the td for the song order
        let ordel = element.childNodes[0];
        if (neword < 1) {
            // song is not one we want.
            // if this song was already chosen, un-choose it and
            // blank out the order. choosing it again will put it 
            // at the current end.
            element.classList.remove("chosen");
            // set the song order to &nbsp;
            ordel.textContent = "\xa0";
        } else {
            // song is one we want. set its ord based on
            // position in songlist, and add it to chosen class.
            ordel.textContent = neword.toString();
            element.classList.add("chosen");
        }
    }
    // set songorder global, so new selections will get the correct ord.
    songorder = songlist.length;
}

function init() {
    loadDoc("musiclib.xml");

    // init date picker to next Tuesday (today if it's Tuesday)
    let d = new Date();
    d.setDate(d.getDate() + (7 - d.getDay() + 2) % 7);
    let datel = document.getElementById("eventdate");

    let day = d.getDate();
    let mo = d.getMonth() + 1;

    // make zero-left-padded strings of day and mo
    let dstr = day.toString().padStart(2, 0);
    let mstr = mo.toString().padStart(2, 0);

    datel.value = d.getFullYear() + "-" + mstr + "-" + dstr + "T19:00";

    // leave first venue "empty" so user knows that one still needs to be selected.
    let venlist = ["", "Rehearsal", "Chehalis West", "Colonial", "Prestige Care",
                         "Sharon Care", "Vintage", "Woodland Village"];

    let sel = document.getElementById("vensel");

    for (let ven of venlist) {
        let opt = document.createElement("option");
        opt.value = ven;
        opt.data_value = "";
        sel.append(opt);
    }

    // get the event-list json from local storage
    let eljson = localStorage.getItem('TunersEvents');

    // if we got a list, convert to a dict (Object, really)
    // and add the desired number of most-recent events to the location selector.

    if (eljson) {
        eventlist = JSON.parse(eljson);

        if (nevshow > 0) {
            // sort event list newest first
            var sorted = [];
            for (let evndx in eventlist) {
                sorted.push(evndx);
            }
            sorted.sort(function(a, b) {
                if (a < b) { return 1;
                } else if (a > b) { 
                    return -1;
                } else {
                    return 0;
                }
            });

            let nadd = 0;
            for (let evndx of sorted) {
                let ev = eventlist[evndx];

                let opt = document.createElement("option");
                opt.data_value = evndx;
                opt.value = `${ev['where']} - ${ev['when']}`;
                sel.append(opt);
                nadd += 1;
                if (nadd >= nevshow) {
                    break;
                }
            }
        }
    }
}

</script>
</head>
<body onload="init()">
<table border="1" id="tabid" oncontextmenu="selme(this)">
<tr><th colspan='2'>
<label>Songs for:
<input list="vensel" class="select-css" name="venue" onChange="evsel(this)"/></label>
<datalist id="vensel">
</datalist>
<label for="eventdate">on</label>
<input type="datetime-local" class="select-css" value="" id="eventdate" step="900">
</th></tr>
<tr><td id='catboxes' colspan='2'>
 <input type='checkbox' name='cats' checked="1" onchange="togcat(this)">Current</input>
 <input type='checkbox' name='cats' checked="1" onchange="togcat(this)">PoleCat</input>
 <input type='checkbox' name='cats' checked="1" onchange="togcat(this)">PoleCatII</input>
 <input type='checkbox' name='cats' checked="1" onchange="togcat(this)">Show</input>
 <input type='checkbox' name='cats' onchange="togcat(this)">Christmas</input>
 <input type='checkbox' name='cats' onchange="togcat(this)">Others</input>
</td></tr>
<tr>
<th><input type="button" class="donebutt" value="Save" onclick="alldone()"/></th>
<th>Song Title</th>
</tr>
<tr id="songtable"></tr>
</table>
</body>
</html>
