<!DOCTYPE html>
<!-- $Id: evhistory.html,v 1.1 2022/06/27 00:57:38 dfm Exp dfm $
     $Log: evhistory.html,v $
     Revision 1.1  2022/06/27 00:57:38  dfm
     Initial revision


     display cheat sheet for any event that has one, -or-
     display summary of songs sung at a list of events.

-->
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Event Histories</title>
<link rel="stylesheet" href="pick.css" />
<link rel="stylesheet" href="//code.jquery.com/ui/1.13.1/themes/base/jquery-ui.css">
<script src="https://code.jquery.com/jquery-3.6.0.js"></script>
<script src="https://code.jquery.com/ui/1.13.1/jquery-ui.js"></script>
<script type="text/javascript">

var aliasfor = []; // gives main sid for an alias sid
var allcats = []; // all categories from musiclib
var catSelected = []; // indexed by cat, true if cat checked
var cheatorsumm = "cheat"; // "cheat" or "summary" to control which report to generate
var eventlist = {}; // indexed by ymdhm of event, value is event definition
var evndx = ""; // event date, used to index eventlist. passed to ch.html
var lowerVenue = {}; // lists of dtndx for lower-case venue
var newevent; // event passed to ch.html
var newestFirst = []; // most recent matches list, newest (biggest) first
var songlib = []; // indexed by song name, value list of sids
var songlist = []; // all song sids for an event
var songobj = []; // indexed by sid, value is song object
var songorder = 0; // ordinal of last picked
var songsincat = []; // indexed by category, value is list of song names
var venue = ""; // venue for event
var voices = ['bass', 'bari', 'lead', 'tenor', 'mix', 'none'];

function loads() {
    // start loading the musiclib and eventlist xml files. xhr will call the onload function when it is ready. 

    const xhr = new XMLHttpRequest();
    xhr.onerror = function() {
      console.log("Error while getting musiclib.xml");
    }

    xhr.open("GET", "musiclib.xml");
    xhr.responseType = "document";
    xhr.send();

    xhr.onload = function () {
        // musiclib is ready. start loading events.xml, 
        // then process the lib xml
        const xhr2 = new XMLHttpRequest();
        xhr2.onerror = function() {
          console.log("Error while getting events.xml");
        }

        xhr2.open("GET", "events.xml");
        xhr2.responseType = "document";
        xhr2.send();

        xhr2.onload = function () {
            // events.xml is ready.
            let eventxml = xhr2.responseXML.documentElement;

            for (let eventNode of eventxml.children) {
                let evt = [];
                for (let att of eventNode.attributes) {
                    evt[att.name] = att.value;
                }
                let when = evt['when'];
                let where = evt['where'];
                let dtndx = evt['dtndx'];

                let brief = true;
                if (brief) {
                    // brief mode songlist and qtetsongs are given as event attributes,
                    // and are each a string of blank-separated sids.
                    evt['songlist'] = evt['songlist'].split(" ");
                    if (evt.hasOwnProperty('qtetsongs')) {
                        evt['qtetsongs'] = evt['qtetsongs'].split(" ");
                    }
                } else {
                    evt['songlist'] = [];
                    let qtetsongs = [];
                    for (let songNode of eventNode.children) {
                        let sattrs = [];
                        for (let att of songNode.attributes) {
                            sattrs[att.name] = att.value;
                        }
                        let sid = sattrs['sid'];
                        evt['songlist'].push(sid);
                        if (sattrs.hasOwnProperty('qtet')) {
                            qtetsongs.push(sid);
                        }
                    }

                    if (qtetsongs.length > 0) {
                        evt['qtetsongs'] = qtetsongs;
                    }
                }

                eventlist[dtndx] = evt;
                let lowven = evt['where'].toLowerCase();
                if (! lowerVenue.hasOwnProperty(lowven)) {
                    lowerVenue[lowven] = [];
                }
                lowerVenue[lowven].push(dtndx);
            }

            // init searchsel with all events.
            let sel = document.getElementById("searchsel");

            // get a list of dtndx in newest first order
            newestFirst = Object.keys(eventlist).sort((a, b) => a < b ? 1 : a > b ? -1 : 0);
            for (let dtndx of newestFirst) {
                let opt = document.createElement("option");
                let perfev = eventlist[dtndx];
                opt.value = `${perfev['where']} - ${perfev['when']}`;
                opt.dataset.dtndx = dtndx;
                sel.append(opt);
            }

            // events and musiclib xmls both loaded. finish up the load process and wait for user input.

        }
        // process the musiclib xml file
        if (! xhr.responseXML) {
            document.querySelector("#tabid").outerHTML = '<h1 style="color:red">musiclib.xml contains errors!</h1>';
            throw 'musiclib.xml contains errors!';
        }

        let musiclib = xhr.responseXML.documentElement;
        aliasfor = []; // gives main sid for an alias sid
        for (let songNode of musiclib.children) {
            let song = [];
            let categories = [];
            for (let att of songNode.attributes) {
                song[att.name] = att.value;
            }

            let nam = song['name'];
            let sid = song['id'];

            if ('aliasfor' in song) { 
                let asid = song['aliasfor'];
                aliasfor[sid] = asid;

                if (! songlib.hasOwnProperty(nam)) {
                    songlib[nam] = [];
                }
            }

            for (let prop of songNode.children) {
                if (prop.nodeName == "category") {
                    let cat = prop.textContent;
                    categories.push(cat);
                    if (! allcats.includes(cat)) {
                        allcats.push(cat);
                    }
                    if (! songsincat.hasOwnProperty(cat)) {
                        songsincat[cat] = [];
                    }
                    songsincat[cat].push(nam);
                } else if (prop.nodeName == "tracks") {
                    let tracks = [];
                    for (let subp of prop.children) {
                        if (subp.nodeName == "voice") {
                            let voice = [];
                            let vname = 'phony';
                            for (let att of subp.attributes) {
                                if (att.name == 'voice') {
                                    vname = att.value;
                                } else {
                                    voice[att.name] = att.value;
                                }
                            }
                            tracks[vname] = Object.assign(voice);
                        }
                    }
                    song[prop.nodeName] = Object.assign(tracks);
                } else if (prop.nodeName == "sheet") {
                    let sheet = [];
                    for (let att of prop.attributes) {
                        sheet[att.name] = att.value;
                    }
                    song[prop.nodeName] = Object.assign(sheet);
                } else {
                    song[prop.nodeName] = prop.textContent;
                }
            }
            if (categories.length > 0) {
                song['categories'] = Object.assign(categories);
            }

            if (! songlib.hasOwnProperty(nam)) {
                songlib[nam] = [];
            }
            songlib[nam].push(sid);

            // clone the song object and add to list
            if (songobj.hasOwnProperty(sid)) {
                throw "found multiple songs with sid " + sid;
            }
            songobj[sid] = Object.assign(song);
        }

        for (let song in songlib) {
            if (songlib[song].length > 1) {
                for (let sid of songlib[song]) {
                    if (songobj[sid]['categories'].includes("Old")) {
                        let oldnam = song + " (Old)";
                        // change song name for this sid in the list of objects
                        songobj[sid]['name'] = oldnam;
                        // add modified name to songlib, for sid
                        if (! songlib.hasOwnProperty(oldnam)) {
                            songlib[oldnam] = [];
                        }
                        songlib[oldnam].push(sid);
                        // remove sid from list for unmodified name
                        let n = songlib[song].indexOf(sid);
                        songlib[song].splice(n, 1);
                        // console.log(oldnam);
                    }
                }
            }
        }
    }
}

function venuesel(el) {
    // a venue has been selected. el is the input element
    // note: this routine is called when a venue is selected,
    // and every time an entry is made in the search window.

    let targ = el.value.toLowerCase();

    let matches = [];
    // scan the event list for events matching selected venue
    for (let lowven in lowerVenue) {
        if (lowven.includes(targ)) {
            for (let d of lowerVenue[lowven]) {
                matches.push(d);
            }
        }
    }
    // sort the dates biggest (newest) first
    newestFirst = matches.sort((a, b) => a < b ? 1 : a > b ? -1 : 0);
    let html = '';

    let since = document.querySelector("#since").value.replaceAll("-", "");

    for (let dtndx of newestFirst) {
        if (dtndx >= since) {
            let perfev = eventlist[dtndx];
            let when = perfev['when'];
            let where = perfev['where'];
            html += `<tr><td>${where}</td><td>${when}</td><td class="hidden">${dtndx}</td></tr>\n`;
        }
    }
    html += "</table>\n";

    document.querySelector("#eventTable").innerHTML = html;
    document.getElementById("cheatList").innerHTML = "";
    if(event.target.id == "venuesel") {
        document.getElementById("searchpick").value = "";
    }
}

function eventsel(el) {
    let tr = el.closest("tr");
    let when = tr.children[1].textContent;
    let dtndx = tr.children[2].textContent;
    let perfev = eventlist[dtndx];

    makelist(perfev);

    // console.log(`${perfev['when']} at ${perfev['where']}`);
    // for (let sid of perfev['songlist']) {
        // console.log(`${songobj[sid]['name']}`);
    // }
}

function init() {
    // start the load of the xmls.
    loads();
    document.querySelector("#venuesel").addEventListener('change', perfev => venuesel(perfev.target));
    document.querySelector("#searchpick").addEventListener('keyup', keyev => venuesel(keyev.target));
    document.querySelector("#eventTable").addEventListener('click', perfev => eventsel(perfev.target));
}

function setvoice(el) {
    let voice = el.value;
    // show the class we were called with (i.e., remove "hidden")
    for (let element of document.getElementsByClassName(voice)) {
       element.classList.remove("hidden");
    }
    let others = new Set(voices);
    others.delete(voice);
    // don't show the rest of the classes
    for (let v of others) {
        for (let element of document.getElementsByClassName(v)) { element.classList.add("hidden"); }
    }
    if (voice != "none") {
        localStorage.setItem("defaultVoice", voice);
    }
}

function makelist(perfev) {
    let evname = `${perfev['where']} - ${perfev['when']}`;
    let html = `<title>${evname}</title>
<link rel='stylesheet' href='pick.css' />
<table id='cheatTable'>
<tr><td id="evtitl" colspan="3" class="tabletitle">${evname}</td></tr>
    `

    let songlist = perfev['songlist'];
    let qtetsongs = [];
    if (perfev.hasOwnProperty('qtetsongs')) {
        qtetsongs = perfev['qtetsongs'];
    }

    for (let sid of songlist) {
        let nam = songobj[sid]['name'];
        let songTitle = nam; // songTitle becomes songname (notes) [location]
        let key = songobj[sid]['key'];
        let keyclass = "key";
        if (songobj[sid].hasOwnProperty('pitch')) {
            let pit = songobj[sid]['pitch'];
            if (pit != "") {
                key = 'blow ' + pit;
                keyclass = "pitch";
            }
        }
        let words = songobj[sid]['words'];
        if (songobj[sid].hasOwnProperty("notes")) {
            songTitle += ` (${songobj[sid]['notes']})`;
        }
        if (songobj[sid].hasOwnProperty("location")) {
            songTitle += ` [${songobj[sid]['location']}]`;
        }
        let picks = "";
        if (songobj[sid].hasOwnProperty("tracks")) {
            for (let voice of voices) {
                let choices = [];
                let ancclass = voice;
                if (voice != "mix") {
                    ancclass += " hidden";
                }
                if (songobj[sid]['tracks'].hasOwnProperty(voice)) {
                    let gdid = songobj[sid]['tracks'][voice]['gdid'];
                    let mods = songobj[sid]['tracks'][voice]['mods'];
                    choices.push(`<a href='https://drive.google.com/open?id=${gdid}'>${songTitle} : ${mods}</a>`);
                } else if (voice == "none") {
                    // don't include location for voice none
                    let short = nam;
                    if (songobj[sid].hasOwnProperty("notes")) {
                        short += ` (${songobj[sid]['notes']})`;
                    }
                    choices.push(short);
                } else { 
                    // no tracks for this voice
                    choices.push(songTitle);
                }
                picks += `<div class='${ancclass}'>` + choices.join("<br/>\n") + "\n</div>";
            }
        } else {
            picks = songTitle + "\n";
        }

        let cl = "class='song'";
        if (qtetsongs.includes(sid)) {
            cl = "class='song qtet'";
        }
        html += `<tr ${cl}><td class='${keyclass}'>${key}</td><td>${picks}</td><td>${words}</td></tr>\n`;
    }
    html += `<tr><td colspan='3' class='partsel'>
<fieldset class='partsel'>
<legend>Show voice</legend>
 <input type="radio" id="seltenor" name="part" value="tenor" onclick="setvoice(this)">tenor</input>
 <input type="radio" id="sellead" name="part" value="lead" onclick="setvoice(this)">lead</input>
 <input type="radio" id="selbari" name="part" value="bari" onclick="setvoice(this)">bari</input>
 <input type="radio" id="selbass" name="part" value="bass" onclick="setvoice(this)">bass</input>
 <input type="radio" id="selmix" name="part" value="mix" onclick="setvoice(this)">mix</input>
 <input type="radio" id="selnone" name="part" value="none" onclick="setvoice(this)">none</input>
</fieldset>
</td></tr>
`;
    dialel = document.querySelector("#dialog");
    dialel.innerHTML = html;
    $( "#dialog" ).dialog({ title: evname, width: "auto" });
}
function scrollToTop() {
    document.getElementById("tabid").scrollIntoView({block: "end"});
}
function summary(el) {
    // newestFirst has the most recent list of eventlist indices to summarize.
    // build a list of (category, songname, dtndx) from those events and sort it.
    // then collapse the sorted list to a dict by [cat][song], value [ntimes, last]

    // get the start date from the date picker and remove the "-"s
    let dpdate = document.querySelector("#since").value;
    let since = dpdate.replaceAll("-", "");

    let cats = allcats;
    let header = "Song Performance Summary, all cats, since " + dpdate;
    if (el.id == "cursumm") {
        cats = ['Current', 'Show', 'PoleCat', 'PoleCatII'];
        header = "Song Performance Summary since " + dpdate;
    }

    let catSong = [];
    for (let cat of cats) {
        catSong[cat] = [];
        for (let song of songsincat[cat]) {
            catSong[cat][song] = [];
            catSong[cat][song]['ntimes'] = 0;
            catSong[cat][song]['last'] = "";
        }
    }

    // now process every song of every event of interest.
    for (let dtndx of newestFirst) {
        if (dtndx >= since) {
            let ev = eventlist[dtndx];
            qtetsongs = [];
            if (ev.hasOwnProperty('qtetsongs')) {
                qtetsongs = ev['qtetsongs'];
            }
            for (let sid of ev['songlist']) {
                // don't include qtet songs in summary.
                if (! qtetsongs.includes(sid)) {
                    let nam = songobj[sid]['name'];
                    for (let cat of songobj[sid]['categories']) {
                        if (cats.includes(cat)) {
                            catSong[cat][nam]['ntimes']++;
                            if (dtndx > catSong[cat][nam]['last']) {
                                catSong[cat][nam]['last'] = dtndx;
                            }
                        }
                    }
                }
            }
        }
    }
    let sortedCats = Object.keys(catSong).sort();

    // special-case KTWWS - (almost) always sung with LGTA
    let ktwws = "Keep The Whole World Singing";
    let lgta = "Let's Get Together Again";

    // if we don't have ktwws or it reports 0 times, use lgta instead.
    if (! catSong['Current'].hasOwnProperty(ktwws) || catSong['Current'][ktwws]['ntimes'] == 0) {
        catSong['Current'][ktwws] = catSong['Current'][lgta];
    }

    let html = `<title>Summary of song performances</title>
<link rel='stylesheet' href='pick.css' />
<table id='cheatTable'><tr><td>
`;
    let prevcat = "";

    // mdy(dtndx) returns date in mm/dd/yyyy format
    var mdy = s => s.substring(4,6) + "/" + s.substring(6,8) + "/" + s.substring(0,4);

    for (let cat of sortedCats) {
        let sortedSongs = Object.keys(catSong[cat]).sort();
        let last, ntimes;
        for (let song of sortedSongs) {
            last = catSong[cat][song]['last'];
            ntimes = catSong[cat][song]['ntimes'];
            if (prevcat == "") {
                prevcat = cat;
                html += `<tr><td><table class='catperf'><caption>${cat}</caption>\n`;
                html += `<tr><th>Song</th><th>Times</th><th>Last</th></tr>`;
            } else if (cat != prevcat) {
                html += `</table></td></tr>\n`;
                // just closed table for prev cat. start one for cat
                html += `<tr><td><table class='catperf'><caption>${cat}</caption>\n`;
                html += `<tr><th>Song</th><th>Times</th><th>Last</th></tr>`;
                prevcat = cat;
            }
            if (ntimes == 0) {
                lasttd = "<td class='never'>";
            } else {
                last = mdy(last);
                lasttd = "<td>";
            }
            html += `<tr><td>${song}</td><td>${ntimes}</td>${lasttd}${last}</td></tr>\n`;
        }
    }
    // close the last cat table, then the outer cheatTable
    html += `</table></td></tr>
</table>
`;
    // console.log("--- Summary HTML ---");
    // console.log(html);
    // console.log("--- end of Summary HTML ---");

    dialel = document.querySelector("#dialog");
    dialel.innerHTML = html;
    $( "#dialog" ).dialog({ title: header, width: "auto" });
}
</script>
</head>
<body onload="init()">
<table id="wrap">
    <tr><td>
    <table border="1" id="tabid">
    <tr><th>
        <select id="venuesel" class="select-css" name="venue">
        <option value="" disabled selected hidden>select Venue</option>
        <option>Rehearsal</option>
        <option>Chehalis West</option>
        <option>Colonial</option>
        <option>Prestige Care</option>
        <option>Sharon Care</option>
        <option>Vintage</option>
        <option>Woodland Village</option>
        </select>
        </th><th>
        <input type="text" id="searchpick" class="select-css" name="venue" placeholder="or Search"/>
        <datalist id="searchsel">
        </datalist>
    </th></tr>
    <tr><th colspan="2">
    <input type="radio" id="allsumm" name="summtype" onclick="summary(this)"></input>
    <label for="cursumm"> &lt; All - Summary - Current &gt;</label>
    <input type="radio" id="cursumm" name="summtype" onclick="summary(this)"></input>
    <label for="since">Since: <input type="date" id="since" value="2020-01-01" min="2015-01-01" max="2022-04-01"></input></label>

    </th></tr>
    <tr><th>Where</th><th>When</th></tr>
        <tbody id="eventTable">
    </table>
</td><td> <!-- wrap -->
    <table id="cheatTable">
            <tbody id="cheatList">
    </table>
</td></tr></table> <!-- wrap -->

<div id="dialog" title="Basic dialog"> </div>
</body>
</html>
